<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>十大经典的排序算法</title>
  
  <link rel="canonical" href="http://example.com/2021/04/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">
  
  <meta name="description" content="简介十大排序算法应该是每个程序员必会的知识, 之前虽然会用到, 但是并没有系统地总结过, 因此这里做一次总结。 十大排序算法分别是:   冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序  排序算法的稳定性排序算法的稳定性是指, 能保证两个相等的元素在排">
  
  
  <meta name="author" content="Mett Li">
  
  
  
  <meta property="og:site_name" content="Hexo" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="十大经典的排序算法" />
  
  <meta property="og:description" content="简介十大排序算法应该是每个程序员必会的知识, 之前虽然会用到, 但是并没有系统地总结过, 因此这里做一次总结。 十大排序算法分别是:   冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序  排序算法的稳定性排序算法的稳定性是指, 能保证两个相等的元素在排">
  
  <meta property="og:url" content="http://example.com/2021/04/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="十大经典的排序算法">
  
  <meta name="twitter:description" content="简介十大排序算法应该是每个程序员必会的知识, 之前虽然会用到, 但是并没有系统地总结过, 因此这里做一次总结。 十大排序算法分别是:   冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序  排序算法的稳定性排序算法的稳定性是指, 能保证两个相等的元素在排">
  
  
  
  
  <meta name="twitter:url" content="http://example.com/2021/04/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  
  
<link rel="stylesheet" href="/css/user.css">

  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn">🌑</div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden>☀️</div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      小站
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        <a href="/">Home</a>
        
          
          <a href="/About" class="ml">About</a>
          
        
        
          
            <a href="mailto:xd842303863@163.com" target="_blank" class="ml">Email</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>十大经典的排序算法</h2>

  <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>十大排序算法应该是每个程序员必会的知识, 之前虽然会用到, 但是并没有系统地总结过, 因此这里做一次总结。</p>
<p>十大排序算法分别是: </p>
<ul>
<li><a href="about:blank#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
<li><a href="about:blank#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="about:blank#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="about:blank#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="about:blank#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="about:blank#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="about:blank#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="about:blank#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></li>
<li><a href="about:blank#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></li>
<li><a href="about:blank#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
</ul>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>排序算法的稳定性是指, 能保证两个相等的元素在排序前和排序后的相对顺序是相同的。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先比较第一个和第二个元素, 若第一个元素大于第二个元素, 则交换位置。之后以相同的规则比较第二个和第三个元素、第三个和第四个元素, 直到最后一对相邻的元素为止。这样一趟比较下来, 最大的元素便会跑到数组的最后。 之后除去最后一个元素, 对剩余的元素重复上述过程, 直到排序完成。 有一个值得优化的地方, 如果数组本身就是有序的, 则第一趟比较时不会发生交换, 那么我们便可以直接返回。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSorting</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">ArrayIsSorted</span> = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="title class_">ArrayIsSorted</span> = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 交换两个元素的位置</span></span><br><span class="line">                [arr[j], arr[j - <span class="number">1</span>]] = [arr[j - <span class="number">1</span>], arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组是排序好的数组</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">ArrayIsSorted</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(n^2)</strong></li>
<li><strong>空间复杂度: O(1)</strong></li>
<li>冒泡排序属于<strong>稳定</strong>的排序算法, 是原地排序。</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先, 从数组中找到最小的元素, 和第一个元素交换位置。之后排除第一个元素, 在剩余元素中找到最小的元素, 与第二个元素交换位置。直到所有元素都完成排序为止。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> min = arr[i];</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; min) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(n^2)</strong></li>
<li><strong>空间复杂度: O(1)</strong></li>
<li>选择排序属于<strong>不稳定</strong>的排序算法, 是原地排序。</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>插入排序, 顾名思义, 就是把元素 “插入” 到它应该在的位置。 从第二个元素开始, 与左边的元素进行比较。若当前元素比与其左侧相邻的元素小, 则交换二者位置。之后继续将当前元素与左边第二个元素做比较, 直到左侧没有元素或遇到小于等于当前元素的元素为止。 为了方便理解, 可以看下面的动图。</p>
<p><a href="%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab/01.webp">%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab&#x2F;01.webp</a></p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 若左侧元素比当前元素小, 则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j - <span class="number">1</span>] &lt;= arr[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 交换相邻元素的位置</span></span><br><span class="line">                [arr[j], arr[j - <span class="number">1</span>]] = [arr[j - <span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(n^2)</strong></li>
<li><strong>空间复杂度: O(1)</strong></li>
<li>插入排序属于<strong>稳定</strong>的排序算法, 是原地排序。</li>
</ul>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>希尔排序可以看做是插入排序的一种变种。 不管是冒泡排序还是插入排序, 比较的都是相邻元素之间的大小。如果一个很大的元素处于很靠前的位置, 那么需要移动很多次才能到达它应该在的位置。使用希尔排序, 通过让大元素与不相邻的元素进行比较, 减少其的移动次数, 从而提高时间效率。 希尔排序的思想是, 先让相隔为 gap 的元素彼此之间有序 (此排序过程使用插入排序), 之后逐渐缩小间隔 gap 值, 当 gap &#x3D; 1 时, 整个数组便是有序的了。</p>
<p><img src="/./images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/03.jpg"></p>
<p>需要注意的是，<strong>对各个分组进行插入的时候并不是先对一个组排序完了再来对另一个组排序, 而是轮流对每个组进行排序。</strong></p>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断减小 gap 直至为 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> gap = arr.<span class="property">length</span> &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap = gap &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 对局部进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历 arr[i] 所属的组中在 arr[i] 之前的元素, 将 arr[i] 放在合适的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                    [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(nlgn)</strong></li>
<li><strong>空间复杂度: O(1)</strong></li>
<li>希尔排序属于<strong>不稳定</strong>的排序算法, 是原地排序。</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>简单来说, 归并排序就是指将一个大的无序数组分成两个, 然后分别对两个数组进行排序, 最后再将两个排序后的小数组合并为一个有序的大数组。 为了方便理解, 可以看下面的动图:</p>
<p><a href="%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab/02.webp">%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab&#x2F;02.webp</a></p>
<h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">mergeSort</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>, arr.<span class="property">length</span> &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">mergeSort</span>(arr.<span class="title function_">slice</span>(arr.<span class="property">length</span> &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; left.<span class="property">length</span> || j &lt; right.<span class="property">length</span>; ) &#123;</span><br><span class="line">        <span class="comment">// 其中一个数组所有元素都已经放入 ans 中</span></span><br><span class="line">        <span class="keyword">if</span>(!left[i]) &#123;</span><br><span class="line">            ans = ans.<span class="title function_">concat</span>(right.<span class="title function_">slice</span>(j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!right[j]) &#123;</span><br><span class="line">            ans = ans.<span class="title function_">concat</span>(left.<span class="title function_">slice</span>(i))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较左右两个数组元素的大小</span></span><br><span class="line">        <span class="keyword">if</span>(left[i] &lt;= right[j]) &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(left[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(right[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(nlgn)</strong></li>
<li><strong>空间复杂度: O(n)</strong></li>
<li>归并排序属于<strong>稳定</strong>的排序算法, 不是原地排序。</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>从数组中选择一个元素, 作为中轴元素。所有比此元素大的都放在该元素右边, 所有比此元素小的都放在该元素左边。 之后采用递归的方式, 对中轴元素左右两边的数组 (不包含中轴元素) 重复这一过程即可。</p>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>首先我们来看一下阮一峰阮大大的解法:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> midIndex = arr.<span class="property">length</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> midNumber = arr.<span class="title function_">splice</span>(midIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ele <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ele &lt; midNumber) &#123;</span><br><span class="line">            left.<span class="title function_">push</span>(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.<span class="title function_">push</span>(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>([midNumber], <span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法通俗易懂, 但是使用了额外的空间, 并且是一种不稳定的排序。因此让我们来改进下。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> midIndex = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> midNumber = arr[midIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> leftIndex = left, rightIndex = right; leftIndex &lt;= midIndex &amp;&amp; rightIndex &gt;= midIndex;) &#123;</span><br><span class="line">        <span class="comment">// 找到左侧第一个大于中轴元素的元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[leftIndex] &lt;= midNumber &amp;&amp; leftIndex &lt; midIndex) &#123;</span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到右侧第一个小于中轴元素的元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[rightIndex] &gt;= midNumber &amp;&amp; rightIndex &gt; midIndex) &#123;</span><br><span class="line">            rightIndex--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在左侧没找到大于中轴的元素</span></span><br><span class="line">        <span class="keyword">if</span> (leftIndex == midIndex) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = rightIndex; i &gt; midIndex;) &#123;</span><br><span class="line">                <span class="comment">// 若右侧有小于中轴的元素</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; midNumber) &#123;</span><br><span class="line">                    <span class="keyword">let</span> element = arr[i];</span><br><span class="line">                    <span class="comment">// 删除右侧的元素</span></span><br><span class="line">                    arr.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 将删除的元素插入到 midIndex 之前</span></span><br><span class="line">                    arr.<span class="title function_">splice</span>(midIndex, <span class="number">0</span>, element);</span><br><span class="line">                    <span class="comment">// 由于前插了元素, 因此需要增加 midIndex</span></span><br><span class="line">                    midIndex++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex == midIndex) &#123;</span><br><span class="line">            <span class="comment">// 如果在右侧没有找到大于中轴的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = leftIndex; i &lt; midIndex;) &#123;</span><br><span class="line">                <span class="comment">// 若左侧有大于中轴的元素</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; midNumber) &#123;</span><br><span class="line">                    <span class="keyword">let</span> element = arr[i];</span><br><span class="line">                    <span class="comment">// 删除右侧的元素</span></span><br><span class="line">                    arr.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 将删除的元素插入到 midIndex 之后</span></span><br><span class="line">                    arr.<span class="title function_">splice</span>(midIndex, <span class="number">0</span>, element);</span><br><span class="line">                    <span class="comment">// 由于前面删除了元素, 因此需要减小 midIndex</span></span><br><span class="line">                    midIndex--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 交换左右两侧元素的位置</span></span><br><span class="line">            [arr[leftIndex], arr[rightIndex]] = [arr[rightIndex], arr[leftIndex]];</span><br><span class="line">            leftIndex++;</span><br><span class="line">            rightIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">quickSort</span>(arr, left, midIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">quickSort</span>(arr, midIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(nlgn)</strong></li>
<li><strong>空间复杂度: O(1)</strong></li>
<li>快速排序属于<strong>稳定</strong>的排序算法, 是原地排序。</li>
</ul>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>堆有两种, 堆顶是最大值的堆被称为<code>大顶堆</code>, 堆顶是最小值的堆被称为<code>小顶堆</code>。 堆排序就是把大顶堆的堆顶元素和最后一个元素交换位置, 之后再把剩余元素继续组成大顶堆, 把堆顶与倒数第二个元素交换位置, 然后重复这一过程。</p>
<h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="title function_">downAdjust</span>(arr, i, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶元素与最后一个元素交换</span></span><br><span class="line">        [arr[<span class="number">0</span>], arr[i]] = [arr[i], arr[<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">// 继续用剩余元素组成大顶堆</span></span><br><span class="line">        <span class="title function_">downAdjust</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">downAdjust</span>(<span class="params">arr, parent, len</span>) &#123;</span><br><span class="line">    <span class="comment">//临时保存要下沉的元素</span></span><br><span class="line">    <span class="keyword">let</span> temp = arr[parent];</span><br><span class="line">    <span class="comment">//定位左孩子节点的位置</span></span><br><span class="line">    <span class="keyword">let</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//开始下沉</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= len) &#123;</span><br><span class="line">        <span class="comment">// 如果右孩子节点比左孩子大，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= len &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">// 如果孩子节点小于或等于父节点，则下沉结束</span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt;= temp) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 父节点进行下沉</span></span><br><span class="line">        arr[parent] = arr[child];</span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(nlgn)</strong></li>
<li><strong>空间复杂度: O(1)</strong></li>
<li>堆排序属于<strong>不稳定</strong>的排序算法, 是原地排序。</li>
<li>堆这种数据结构存在的意义? 如果需要的仅仅是一个序列, 使用排序很快就可以完成。但是, 如果我们面对的是一个随时会更新的序列, 那么我们既需要把更新的元素正确的插入序列中, 也需要在序列被划分为任意子集时可以得出子集的最大值和最小值。这个时候, 堆便能派上用场啦。</li>
</ul>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>计数排序的基本思想是: 把数组元素作为数组的下标, 原数组中每有一个对应的数组元素, 就在新数组中以此元素下标的、对应的元素上加一。最后统计新数组各个元素的值, 然后创建新数组。</p>
<h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = [];</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计原数组中各元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = arr[i];</span><br><span class="line">        <span class="keyword">if</span>(count[index] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            count[index]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count[index] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="title function_">push</span>(i);</span><br><span class="line">                arr[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(n)</strong></li>
<li><strong>空间复杂度: O(n)</strong></li>
<li>计数排序属于<strong>不稳定</strong>的排序算法, 不是原地排序。</li>
<li>计数排序有<strong>两个缺陷</strong>: 一个是如果原数组最大值和最小值相差很大, 那么需要的额外空间也很大, 并且中间会有许多空白, 造成不必要的浪费。二是如果原数组中的元素不是正整数, 那么就无法使用该方法。</li>
</ul>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>桶排序的基本思路是, 将最大值和最小值中间数等分为几个区间, 每个区间称为桶。将数组元素放入桶中, 每个桶中都是有序的。最后把各个桶之间汇总起来, 形成有序的数组。</p>
<p><img src="/./images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/04.jpg"></p>
<h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bucketSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最大值和最小值</span></span><br><span class="line">    <span class="keyword">let</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ele <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ele &lt; min) &#123;</span><br><span class="line">            min = ele;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ele &gt; max) &#123;</span><br><span class="line">            max = ele;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容量为 5 的桶</span></span><br><span class="line">    <span class="keyword">let</span> buckets = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原数组元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ele <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="comment">// 注意: 若桶的容量为 n, 那么除的量就应该为 n - 2</span></span><br><span class="line">        <span class="keyword">let</span> bucketIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((ele - min) / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buckets[bucketIndex] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            buckets[bucketIndex] = [ele];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> bucket = buckets[bucketIndex];</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bucket[index] &lt; ele &amp;&amp; index &lt; bucket.<span class="property">length</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bucket.<span class="title function_">splice</span>(index, <span class="number">0</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(bucket <span class="keyword">of</span> buckets) &#123;</span><br><span class="line">        ans = ans.<span class="title function_">concat</span>(bucket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(n)</strong></li>
<li><strong>空间复杂度: O(n)</strong></li>
<li>桶排序属于<strong>稳定</strong>的排序算法, 不是原地排序。</li>
</ul>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>基数排序的基本思路是: 先按照个位数来排序, 再按照十位数来排序, 然后是百位数、千位数等, 排到最高位的时候, 就是一组有序的元素了。在各个位进行排序时, 是使用桶来进行排序的。</p>
<p><a href="%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab/05.webp">%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab&#x2F;05.webp</a></p>
<h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">radixSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最高位</span></span><br><span class="line">    <span class="keyword">let</span> maxRadix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ele <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentEle = ele;</span><br><span class="line">        <span class="keyword">let</span> currentRadix = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (currentEle &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            currentEle /= <span class="number">10</span>;</span><br><span class="line">            currentRadix++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentRadix &gt; maxRadix) &#123;</span><br><span class="line">            maxRadix = currentRadix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容量为 10 的桶</span></span><br><span class="line">    <span class="keyword">let</span> buckets = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照不同位进行排序</span></span><br><span class="line">    <span class="keyword">let</span> radix = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (radix &lt; maxRadix) &#123;</span><br><span class="line">        <span class="comment">// 将对应数字放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> ele <span class="keyword">of</span> arr) &#123;</span><br><span class="line">            <span class="keyword">let</span> currentEle = ele + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">let</span> bucketIndex = radix == <span class="number">0</span> ? currentEle.<span class="title function_">slice</span>(-<span class="number">1</span>) : currentEle.<span class="title function_">slice</span>(-radix - <span class="number">1</span>, -radix) == <span class="string">&#x27;&#x27;</span> ? <span class="number">0</span> : currentEle.<span class="title function_">slice</span>(-radix - <span class="number">1</span>, -radix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buckets[bucketIndex] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                buckets[bucketIndex] = [ele];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> bucket = buckets[bucketIndex];</span><br><span class="line">                <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (bucket[index] &lt; ele &amp;&amp; index &lt; bucket.<span class="property">length</span>) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bucket.<span class="title function_">splice</span>(index, <span class="number">0</span>, ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 汇总合并后重新放入原数组中</span></span><br><span class="line">        arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> bucket = buckets[i] === <span class="literal">undefined</span> ? [] : buckets[i];</span><br><span class="line">            arr = arr.<span class="title function_">concat</span>(bucket);</span><br><span class="line">            <span class="comment">// 清空桶中数据</span></span><br><span class="line">            buckets[i] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        radix++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>时间复杂度: O(n)</strong></li>
<li><strong>空间复杂度: O(n)</strong></li>
<li>基数排序属于<strong>不稳定</strong>的排序算法, 不是是原地排序。</li>
<li>基数排序<strong>只对全是正整数的数组有效,</strong> 对于有小数或负数存在的数组无能为力。</li>
</ul>
<h1 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h1><p><img src="/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab/06.png" alt="%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%206a28088456b145aeaf757e576f843aab/06.png"></p>

  <p><a class="classtest-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a> — Apr 7, 2021</p>
  


        </div>
        <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div>
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      

      

      

      

      

    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>